import type { Marp } from '@marp-team/marp-core';
import { Marpit } from '@marp-team/marpit';
type FunctionalEngine<T extends typeof Marpit = typeof Marpit> = (constructorOptions: ConstructorParameters<T>[0] & {
    readonly marp: Marp;
}) => Marpit | typeof Marpit | Promise<Marpit | typeof Marpit>;
export type Engine<T extends typeof Marpit = typeof Marpit> = Marpit | typeof Marpit | FunctionalEngine<T>;
export type ResolvableEngine<T extends typeof Marpit = typeof Marpit> = Engine<T> | string;
export declare class ResolvedEngine<T extends Engine = Engine> {
    klass: T;
    private _cachedPackage?;
    private static _defaultEngine;
    static resolve<T extends Engine = Engine>(engine: ResolvableEngine | ResolvableEngine[], from?: string): Promise<ResolvedEngine<T>>;
    static resolveDefaultEngine(): Promise<ResolvedEngine<typeof Marp>>;
    getPackage(): Promise<Record<string, any> | null>;
    private static resolveModule;
    private constructor();
    private resolvePackage;
    static isESMAvailable(): boolean;
    private static _silentImportOrRequire;
    private static _silentImport;
    private static _silentRequire;
    private findClassPath;
}
export {};
