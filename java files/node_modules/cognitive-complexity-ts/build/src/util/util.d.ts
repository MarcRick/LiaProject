export declare function countNotAtTheEnds<T>(arr: T[], count: (elem: T) => boolean): number;
export declare function doesNotThrow<T>(promise: Promise<T>): Promise<boolean>;
/**
 * Builds an object from a list of keys whose values are based on the key itself,
 * but where that value is produced asynchronously.
 *
 * This function starts by spawning a promise to generate the value for each key,
 * and ends when all values have been produced.
 * This is faster than spawning promises in sequence.
 */
export declare function keysToAsyncValues<K extends keyof any, V>(keys: K[], toValue: (elem: K) => Promise<V>): Promise<Record<K, V>>;
/**
 * Builds an object from a list of input items.
 * The keys and values are derived from the input item,
 * but the values either need to be generated asynchronously or not at all.
 */
export declare function createObjectOfPromisedValues<I, K extends keyof any, V>(inputs: I[], toKey: (input: I) => K, toMaybePromise: (input: I) => Promise<V> | undefined): Promise<Record<K, V>>;
export declare function nonNaN(num: number, fallback: number): number;
export declare function repeat(str: string, times: number): string;
export declare function toPromise<T, E>(action: (callback: (err: E, successData: T) => void) => void, errorTransformer?: (err: E) => Error): Promise<T>;
export declare class Unreachable extends Error {
    constructor(reason: string);
}
