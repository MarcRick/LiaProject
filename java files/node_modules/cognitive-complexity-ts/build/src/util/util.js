"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Unreachable = exports.toPromise = exports.repeat = exports.nonNaN = exports.createObjectOfPromisedValues = exports.keysToAsyncValues = exports.doesNotThrow = exports.countNotAtTheEnds = void 0;
function countNotAtTheEnds(arr, count) {
    if (arr.length <= 2) {
        return 0;
    }
    let tot = 0;
    for (let i = 1; i < arr.length - 2; i++) {
        if (count(arr[i])) {
            tot += 1;
        }
    }
    return tot;
}
exports.countNotAtTheEnds = countNotAtTheEnds;
async function doesNotThrow(promise) {
    try {
        await promise;
        return true;
    }
    catch (err) {
        return false;
    }
}
exports.doesNotThrow = doesNotThrow;
/**
 * Builds an object from a list of keys whose values are based on the key itself,
 * but where that value is produced asynchronously.
 *
 * This function starts by spawning a promise to generate the value for each key,
 * and ends when all values have been produced.
 * This is faster than spawning promises in sequence.
 */
async function keysToAsyncValues(keys, toValue) {
    const output = {};
    // Create promises to build the output concurrently.
    // Each promise has a side effect of adding to the output.
    const promises = keys.map(async (key) => {
        output[key] = await toValue(key);
    });
    // Only return when all effects have been applied.
    await Promise.all(promises);
    return output;
}
exports.keysToAsyncValues = keysToAsyncValues;
/**
 * Builds an object from a list of input items.
 * The keys and values are derived from the input item,
 * but the values either need to be generated asynchronously or not at all.
 */
async function createObjectOfPromisedValues(inputs, toKey, toMaybePromise) {
    const output = {};
    // Create a Promise for each input entry
    // that may perform another asynchronously task to generate a key-value pair.
    // If it does so, that key-value pair is assigned to the output.
    // No key-value will be produced if there is no internal Promise to wait for.
    const promises = [];
    for (const input of inputs) {
        const maybePromise = toMaybePromise(input);
        if (maybePromise !== undefined) {
            const promise = maybePromise.then(value => {
                const key = toKey(input);
                output[key] = value;
            });
            promises.push(promise);
        }
    }
    // make sure all promises have resolved before returning
    await Promise.all(promises);
    return output;
}
exports.createObjectOfPromisedValues = createObjectOfPromisedValues;
function nonNaN(num, fallback) {
    if (Number.isNaN(num)) {
        return fallback;
    }
    return num;
}
exports.nonNaN = nonNaN;
function repeat(str, times) {
    let res = "";
    for (let i = 0; i < times; i++) {
        res += str;
    }
    return res;
}
exports.repeat = repeat;
function toPromise(action, errorTransformer) {
    return new Promise((resolve, reject) => {
        action((err, successData) => {
            if (err) {
                reject(errorTransformer ? errorTransformer(err) : err);
            }
            else {
                resolve(successData);
            }
        });
    });
}
exports.toPromise = toPromise;
class Unreachable extends Error {
    constructor(reason) {
        super("Unreachable branch.\n" + reason);
    }
}
exports.Unreachable = Unreachable;
//# sourceMappingURL=util.js.map