import { cloneSortedOutput, convertToSortedOutput, isSortedContainerOutput, isSortedFileOutput, isSortedFolderOutput, sortProgramByComplexity, sortProgramByName, sortProgramInOrder } from "../domain/sortedOutput.js";
import { removeAll } from "../util.js";
export var Include;
(function (Include) {
    Include[Include["folders"] = 1] = "folders";
    Include[Include["files"] = 2] = "files";
    Include[Include["containers"] = 3] = "containers";
})(Include || (Include = {}));
export var Sort;
(function (Sort) {
    Sort[Sort["inOrder"] = 1] = "inOrder";
    Sort[Sort["complexity"] = 2] = "complexity";
})(Sort || (Sort = {}));
export class ComplexityController {
    constructor(progComp, model, view) {
        this.include = Include.folders;
        this.sortMethod = Sort.inOrder;
        this.model = model;
        this.view = view;
        this.complexity = convertToSortedOutput(progComp);
        this.initialComplexity = cloneSortedOutput(this.complexity);
        this.sort();
        this.model.overwriteComplexity(this.complexity);
        this.view.makeTree(this.complexity);
    }
    collapseAll() {
        this.view.collapseAll();
    }
    expandAll() {
        this.view.expandAll();
    }
    sort() {
        if (this.sortMethod === Sort.inOrder) {
            if (this.include === Include.containers) {
                sortProgramByName(this.complexity);
            }
            else {
                sortProgramInOrder(this.complexity);
            }
        }
        else if (this.sortMethod === Sort.complexity) {
            sortProgramByComplexity(this.complexity);
        }
    }
    setSortBy(method) {
        this.sortMethod = method;
        this.sort();
        this.model.overwriteComplexity(this.complexity);
    }
    filter() {
        this.complexity = cloneSortedOutput(this.initialComplexity);
        const removeWhat = this.include === Include.folders
            ? () => false
            : this.include === Include.files
                ? data => isSortedFolderOutput(data)
                : data => !isSortedContainerOutput(data);
        this.moveComplexityNodes(this.complexity.inner, removeWhat);
        this.reDepth();
        this.sort();
        this.model.overwriteComplexity(this.complexity);
    }
    moveComplexityNodes(inner, removeWhat) {
        const removed = removeAll(inner, removeWhat);
        if (removed.length > 0) {
            inner.push(...removed.flatMap(removedElem => removedElem.inner));
            for (const removedElem of removed) {
                removedElem.inner.splice(0);
                if (isSortedFolderOutput(removedElem)) {
                    this.model.updateFolder(removedElem);
                }
                else if (isSortedFileOutput(removedElem)) {
                    this.model.updateFile(removedElem);
                }
                else if (isSortedContainerOutput(removedElem)) {
                    this.model.updateContainer(removedElem);
                }
            }
            this.moveComplexityNodes(inner, removeWhat);
        }
    }
    reDepth(complexity = this.complexity, depth = 0) {
        complexity.depth = depth;
        complexity.inner.forEach(child => this.reDepth(child, depth + 1));
    }
    setInclude(include) {
        this.include = include;
        this.filter();
    }
}
//# sourceMappingURL=ComplexityController.js.map